# 《JavaScript 高级程序设计》第十三章：事件

## 简介

JavaScript 与 HTML 的交互是通过“事件”实现的，它相当于两者的枢纽，建立起联接关系。

“事件”就是用户或浏览器自生执行的某种动作，例如用户点击(onclick)，浏览器的资源加载(onload)等，我们可以使用“事件侦听器(Listener)”来预定事件，以便事件发生时执行相应的代码，这种实现模式在软件工程中就被称之为“观察员模式”

“事件”最早出现与 `IE3`, `NetSapce Navigator 2`中，在 `IE4` 与 `NN4` 时 API 开始趋于相似，但直到 DOM2 级的事件模块才开始将其标准化为 DOM 事件。目前 IE9+版本已经完全实现了 DOM 事件的核心部分。

> 浏览器的事件系统除了 DOM 事件，还有 BOM 事件，但是由于 BOM 一直缺乏标准规范（HTML5 已经开始标准化），所以有时会跟 DOM 的某些事件在区分上并不十分清晰。

## 事件流

“事件流”描述的是事件被触发后在文档中的传播与接收的顺序，其中 IE 浏览器提出了“事件冒泡流”，NetSapce 提出了“事件捕获流”，它们是相反的概念

### 冒泡事件流

事件冒泡(bubbling)是 IE 提出的事件流。即事件从触发事件的目标元素起沿着 DOM 树层层向上传播至 `window` 为止，也就是说在此范围内的父元素都可以接收到触发的事件。

示意图：

### 捕获事件流

事件捕获(capturing)是 NetSpace 团队提出的。其思路是事件的触发由最顶层的元素 `window` 开始接收，然后再沿着 DOM 树层层传播至实际触发的目标元素为止。

示例图：

### DOM 事件流

DOM 事件流也是标准事件流，它有三阶段：“捕获阶段”、“目标阶段”、“冒泡阶段”。

- 捕获阶段：当一个事件被触发后，就会由 `window` 发出，然后沿着 DOM 树不断的层层向下传播，直到“目标元素”的父元素为止，这一过程就是“捕获阶段”。在捕获的过程中，所有经过的父节点都会触发这个事件，捕获阶段的任务就是建立事件传递的路线，而之后的冒泡阶段便会顺着这条路线再返回至 `window`。由于捕获阶段不会将事件传递到“目标元素”上，所以理论上事件捕获阶段不会触发目标阶段的事件。
- 目标阶段：当事件捕获阶段传递完毕后，下一个要传递的事件接收节点便是实际触发事件的目标元素节点，因此目标阶段就是捕获阶段传递到实际的目标元素的过程，目标阶段所触发的事件就是我们实际所需要触发的事件处理。如果在这一阶段阻止了冒泡，那么 DOM 事件流就会在这里中止。
- 冒泡阶段：目标阶段完成后，事件便会从目标元素的父元素开始沿着捕获阶段的路线以相反的方向从下向上返回最顶层的 `window` 对象。冒泡阶段可以看作是捕获阶段的逆传播。

由 DOM 事件流的传播机制我们可知，目标元素节点是无法同时指定冒泡阶段与捕获阶段的事件，因为目标元素节点的事件就是我们实际所需要触发的事件，它只会再 DOM 流的目标阶段才会被触发执行，而捕获与冒泡的事件都是目标元素的父级元素具有同类型事件时感知触发的，因此事件流的执行顺序是：父元素捕获阶段的事件 -> 当前（目标）元素的目标阶段事件 -> 父元素冒泡阶段的事件。

虽然我们无法为目标元素节点绑定多种事件流的事件，但是我们可以为其所有的父节点同时绑定多种事件流的事件。

```js
var btn = document.getElementById("btn");
btn.parentNode.onclcik = function() {
  alert("冒泡阶段");
};
btn.parentNode.addEventListener(
  "click",
  function() {
    alert("捕获阶段");
  },
  true
);
btn.onclick = function() {
  alert("目标阶段");
};
```

## 事件处理程序

“事件处理程序” 就是响应某个事件的函数或可执行的 JavaScript 语句，也可以称之为“事件侦听器”、“事件句柄”等。
“事件处理程序” 由两部分组成，一部分是“事件属性名”可以看作是“事件处理程序”的函数名，另一部分便是事件处理函数本身,用于事件触发时执行相应的动作。通常我们约定“事件处理程序”属性名是由前缀“on”加上具体的事件名组成，例如 click 事件的事件处理程序（事件属性名、事件句柄属性名）属性名就是 `onclick`，类似的还有 `onload`、`onmouseover` 等。在 DOM 事件体系中，这些事件属性名通常就是 HTML 标签的事件属性名或者 DOM 对象的事件属性名。

```html
<a onclick="alert(1)" onmouseover="alert('mouse')"></a>
```

```js
console.dir(document.body);

/*
{   
    ....
    onchange:null,
    onclick: ƒ onclick(event),
    onclose: null
    ....
}
*/
```

示意图：

“事件”是浏览器的特定动作，它可以被用户或浏览器自身触发，当一个事件被触发后，它便会去查找对应的事件处理程序属性有没有被赋值，如果有，便会执行该“事件处理程序”。
“事件”一直都是存在的，只不过对应的事件处理程序为 `null` ，因此就算事件被触发也不会进行任何操作，而我们常说的事件绑定，其实并不是真的为 DOM 元素或事件目标绑定事件，而是为其事件处理程序属性（事件属性、事件侦听器属性、事件句柄属性）赋值(事件处理函数)。

事件与事件处理程序关系示意图：

为“事件”指定事件处理程序的方式主要有三大类：事件属性赋值、标准的事件监听器、IE 专有的事件监听器，而“事件属性赋值”又可以分为两种：“HTML 事件处理程序” 和 “DOM0 级事件处理程序”。

### HTML 事件处理程序

某个元素支持的每种事件，都可以使用一个与其事件处理程序同名的 HTML 标签属性来指定（即通过标签属性来为对应的事件处理程序赋值）。

```html
<div onclick="javascript:alert('hello!')"></div>
```

在 HTML 中定义事件处理程序时，标签的事件处理程序属性会事先接收一个匿名函数作为实际的事件处理程序，然后将我们要赋值的事件处理函数或可执行的代码加入到这个匿名的函数内执行。

```html
<script>
  function showMessage(self) {
    console.log(this);
    console.log(self);
  }
</script>
<input type="button" name="button1" onclick="showMessage" />
<input type="button" name="button2" onclick="showMessage()" />
<input type="button" name="button3" onclick="showMessage(this)" />
```

单击上面的按钮，我们会发现 button1 根本不执行，而 button2 中打印的 this 指向的是 `window` ，而不是我们认为的当前 dom 对象，最后只有 button3 的执行符合我们的预期，但是使用方式并非我们所期望的形式，而原因就如上所述，我们指定的事件处理函数并没有真的作为事件处理程序来被事件执行，而是在一个匿名的事件处理程序中被调用执行。

```js
var button1 = document.getElementsByName("button1")[0];
var button2 = document.getElementsByName("button2")[0];
var button3 = document.getElementsByName("button3")[0];

//-------------------- RUN ----------------------------

console.dir(button1.onclick); //ƒ onclick(event) { showMessage}
console.dir(button2.onclick); //ƒ onclick(event) {showMessage()}
button3.click(); //<input type="button" name="button3" onclick="showMessage(this)" />
```

HTML 事件处理程序除了有一个容易让人误导的地方外，它还有一个特点，那就是其事件处理程序的作用域链会被 `with` 使用 `document` 对象进行延长，因此 HTML 中的事件处理程序不仅可以有权访问最顶层的 `window` 对象，还可以访问 `document` 对象中的方法或属性。

```html
<input type="button" name="button" onclick="alert(defaultView === window)" />
```

而且，如果当前元素是一个表单输入元素，那么其事件处理程序还会被 `with` 使用 `Form`（当前表单元素所处的 form 元素）对象来延长其作用域链，这样的好处就是我们可以直接在事件处理程序中使用 `name` 来获取同表单域下的其它表单输入元素。

```html
<form>
  <input name="username" />
  <input type="button" name="button" onclick="alert(username.value)" />
</form>
```

**HTML 中事件处理程序的特点：**

- 我们所指定的事件处理函数会被一个匿名的事件处理程序包裹执行。
- HTML 中的事件处理程序内其 `this` 指向的是当前 DOM 对象自身
- HTML 中的事件处理程序其作用域链会被 `with` 集合 `document` 或者表单对象进行延长。

> 虽然 HTML 事件处理程序有其独特点，但让 HTML 与 JavaScript 代码紧密耦合是其最大的缺陷，因此我们要避免使用，通常都是用于 demo 的验证。

### DOM0 级事件处理程序

DOM0 级事件处理程序是非标准的事件处理程序注册方式。这种方式出现于第四代 Web 浏览器中，现已经被所有浏览器支持，成为事实上通用的标准。
使用 DOM0 级指定事件处理程序就是将一个函数赋值给一个事件处理程序属性，因此对比 HTML 事件处理程序，我们指定的事件处理函数就是实际的事件处理程序，所以当一个函数被赋值给一个事件句柄属性后，其函数内部的 `this` 默认指向的就是事件目标对象自身。

```js
function showMessage() {
  console.log(this.tagName); //'BUTTON'
}
button.onclick = showMessage;
```

由于 DOM0 级指定事件处理程序的方式不支持自定义事件流，所以这种方式添加的事件处理程序只能在事件流的冒泡流阶段被处理。
删除 DOM0 级事件处理程序非常简单，只需要为所需的事件处理程序属性的值置为 null 即可。

```js
button.onclick = null;
```

> 同样的删除原理也可以用于 HTML 事件处理程序。

**DOM0 级事件处理程序特点：**

- 事件处理程序中的 this 默认指向的就是事件目标自身。
- 事件处理程序只能在事件流的冒泡流阶段被处理。

### DOM2 级事件处理程序

DOM2 级指定事件处理程序的方式是标准的事件监听器方式，它有两个方法分别是添加监听器 `addEventListener()` 和 移除监听器 `removeEventListener`，这两个方法是在 `EventTarget` 接口(构造函数)上定义的，因此所有的 DOM 节点都可以调用到这两个方法。

“事件监听器”函数需要传入三个参数，分别是事件名，作为事件处理程序的函数和一个布尔值。前两个参数不在赘述，而最后一个布尔值参数则用来指定事件处理程序是在事件流的那个阶段被执行，如果为 `true` 则表示在捕获阶段被执行，而如果为`false`，则表示在冒泡阶段被执行，默认值为 `false`。

“事件监听器”函数的优点不仅体现于可以指定事件处理程序在事件流中的执行阶段，还可以为一个事件指定多个事件处理程序，并在触发后按照顺序执行。

```js
var button = document.getElementById("btn");
button.addEventListener(
  "click",
  function() {
    alert(1);
  },
  false
);
button.addEventListener(
  "click",
  function() {
    alert(2);
  },
  false
);
```

使用 DOM2 级方式来指定事件处理程序虽然方便，但是移除事件处理程序时将会显得很麻烦，当使用 `removeEventListener()` 方法来移除上面两个事件处理程序，我们必须要保证向其传入的参数与添加时的参数完全相同(也就是说，如果参数是函数，则函数的引用也是相同的)，所以上面那种将匿名函数指定为事件除了程序函数的形式将永远也无法被删除。

**DOM2 级事件处理程序特点：**

- 可以自定义事件处理程序的执行阶段。
- 可以同时为一个事件添加多个事件处理程序。
- 事件处理程序内的 `this` 默认指向 DOM 对象自身
- 移除事件处理程序时传入的参数必须与添加时传入的参数完全相同。

### IE 事件处理程序

IE 中也实现了与 DOM2 级类似的两个方法： `attachEvent()` 和 `detachEvent()`，它们都接受相同的两个参数，分别是“事件处理程序属性名”和“事件处理函数”。
由于 IE8 以及更早期版本只支持事件冒泡，所以通过 `attachEvent()` 与 `detachEvent()` 方法指定的事件处理程序都会被添加到冒泡阶段执行。

```js
btn.attachEvent("onclick", function() {});
```

`attachEvent()`方法可以为一个事件添加多个事件处理程序，但是这些事件处理程序的执行顺序是不能确定的。还需要注意的是，通过 `attachEvent()` 方法指定的事件处理程序，其函数内的 `this` 默认指向的是 window,而非目标 DOM 某元素本身。

最后，与 DOM2 级删除事件处理程序的机制相同，当使用`detachEvent()`方法来删除某个事件处理程序时，必须要保证传入的参数与指定时的参数完全相同，也就是说上面那种指定的匿名函数形式的事件处理程序将永远无法被移除。

**IE 事件处理程序特点：**

- 指定时事件处理程序属性的名称是完整的事件属性名称。
- 可以支持为一个事件添加多个事件处理程序。
- 只支持指定冒泡阶段的事件处理程序。
- 指定的事件处理程序函数内部 `this` 默认指向的是 `window`，而非目标 DOM 元素本身。
- 删除时必须要传入与指定时完全相同的参数。

### 跨浏览器的事件处理程序。

通过使用能力检测的方式来为不同的浏览器选择合适的事件处理程序注册方式。
通常我们的优先级是 DOM2 级事件处理程序方式 -> IE 事件处理程序方式 -> DOM0 级事件处理程序方式。

```js
var eventUtil = {
  addEvent: function(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element["event_" + handler.name] = function(event)) {
        handler.call(element, event ||  window.event);
      };
      element.attachEvent("on" + type, element["event_" + handler.name]);
    } else {
      element["on" + type] = handler;
    }
  },
  removeEvent: function(element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, element["event_" + handler.name]);
    } else {
      element["on" + type] = null;
    }
  }
};
```

## 事件对象

### DOM 事件对象

当事件触发时会产生一个“事件对象(evnet)”，这个事件对象包含了所有与该事件相关的信息。包括触发事件的“当前元素(currentTarget)”、触发事件的“目标元素(target)”、“事件类型(type)”以及该事件类型特有的细节信息。

DOM 事件对象会作为事件处理程序的形参来传入到事件处理函数中。

```js
element.onclick = function(event) {
  console.log(event.type);
};
element.addEventListener("click", function(event) {
  console.log(event.type);
});
```

但如果是 HTML 事件处理程序方式，那么“事件对象”会保存在 `window` 窗口对象上，通过 `window.event` 属性我们便可以引用到该事件的“事件对象”。

```html
<input onclick="console.log(event)" />
```

下面是 DOM 事件对象常用的属性或方法：

|         属性/方法          |   取值   |                                                         说明                                                          |
| :------------------------: | :------: | :-------------------------------------------------------------------------------------------------------------------: |
|          bubbles           | Boolean  |                                                  该事件是否支持冒泡                                                   |
|        cancellabel         | Boolean  |                                              该事件是否可以取消默认行为                                               |
|       currentTarget        | Element  |                                        事件处理程序当前正在处理事件的那个元素                                         |
|      defaultPrevented      | Boolean  |                              是否已经调用了 `preventDefault()` 方法取消了事件的默认行为                               |
|           detail           | Integer  |                                                 与事件有关的细节信息                                                  |
|         eventPhase         | Integer  |                         该事件处于事件流中的阶段，1 表示捕获阶段、2 为目标阶段、3 为冒泡阶段                          |
|      preventDefault()      | Function |                                                  取消事件的默认行为                                                   |
| stopImmediatePropagation() | Function | 阻止事件流下一个冒泡或捕获阶段的事件处理程序，同时还会立即阻止当前元素后续同类型的事件多个事件处理程序。(DOM3 级新增) |
|     stopPropagation()      | Function |                                    阻止事件流下一个冒泡或捕获阶段的事件处理程序。                                     |
|           target           | Element  |                                                    事件的目标元素                                                     |
|          trusted           | Boolean  |                                      分别事件是浏览器中的事件还是用户自定义事件                                       |
|            type            |  String  |                                                       事件类别                                                        |
|            view            |  Object  |                                            事件对象对 `window` 对象的引用                                             |

> \*如果在事件处理程序中直接返回 `return false`，效果则等同于同时执行 `preventDefault()` 与 `stopPropagation()` 方法。

在阻止事件流的下一个冒泡或捕获阶段的事件处理程序的执行上，我们可选的方案有两个：`stopPropagation()` 与 `stopImmediatePropagation()` ，它们的区别在于后者不仅能阻止事件流的下一步捕获或冒泡的执行，还能阻止当前元素为同一个事件注册的多个后续执行的事件处理程序。

```js
element.addEventListener("click", function(e) {
  console.log("click1");
  e.stopPropagation(); // 执行该方法只会打印 click1 、click2。
  e.stopImmediatePropagation(); // 执行该方法只会打印 click1。
});

element.addEventListener("click", function(e) {
  console.log("click2");
});

document.body.addEventListener("click", function() {
  console.log("body click");
});
```

> 因此 `stopImmediatePropagation()` 方法在 DOM0 级方式的事件处理程序中基本无效，只能用于 DOM2 级注册事件处理程序的方式中。

在事件处理程序的内部 `this` 永远指向的 `currentTarget`，而 `target` 则是指触发事件的实际目标元素，由于目标元素就是事件流目标阶段的元素节点，所以当 `eventPhase` 为 2 时，`this`、`currentTarget`、`target` 三者时完全相同的。

```js
element.onclick = function(e) {
  if (e.eventPhase === 2) {
    console.log(this === e.currentTarget && this === e.target); //true
  }
};
```

最后，事件对象只会存在事件处理程序执行的期间，一旦事件处理程序执行完毕，那么事件对象就会被回收（究其原因还时在于事件对象时一个形参）。

### IE 事件对象

在 IE 浏览器内，不论是在 HTML 事件处理程序方式还是 DOM0 级事件处理程序的指定方式上，IE 独有的“事件对象”都是保存在 window 对象上，需要通过 `window.event` 进行引用，所以早期获取事件对象的兼容性写法如下所示：

```js
element.onclick = function(event) {
  var event = event || window.event;
};
```

这样对于支持标准 DOM 事件的浏览器中直接通过事件处理程序的参数获取事件对象，而 IE 浏览器则通过全局对象来获取引用。
对于使用 `attachEvent()` 方法指定的事件处理程序，其事件对象的获取与 DOM 事件对象的获取方式相同(可直接通过事件处理程序的参数来获取)。

```js
element.attachEvent("onclick", function(e) {
  console.log(e);
});
```

下面是 IE 事件对象常用的属性：

|     属性     |  取值   |                    说明                    |
| :----------: | :-----: | :----------------------------------------: |
| cancelBubble | Boolean |  是否阻止冒泡，如果赋值为 `true`表示阻止   |
| returnValue  | Boolean | 是否取消默认行为，赋值为 `false` 表示取消  |
|  srcElement  | Element | 获取实际的目标节点，类似于 `target` 属性。 |
|     type     | String  |                  事件类型                  |

在 IE 事件对象中 `event.cancelBubble = true` 等同于 `event.stopPropagation()` 方法，但由于 IE8 及更早的版本只支持事件冒泡，所以该属性无法像 `stopPropagation()` 方法那样还支持阻止事件捕获。

在 IE 事件对象中 `event.returnValue = false` 等同于 `event.preventDefault()` 方法，阻止事件默认的行为。

另外由于 `attachEvent()` 方法自身的缺陷，其注册的事件处理程序内部 `this` 指向的是 `window` 对象而非 DOM 事件对象中的 `currentTarget` 当前元素。

```js
element.attachEvent("onclick", function(e) {
  console.log(this === e.srcElement); // false
});
```

### 跨浏览器的事件对象

对大多数浏览器都支持的事件对象属性或方法进行封装。

```js
var eventUtil = {
  addEvent: function() {
    /*...*/
  },
  removeEvent: function() {
    /*...*/
  },
  getEvent: function(e) {
    return e || window.event;
  },
  getTarget: function(e) {
    return e.target || e.srcElement;
  },
  preventDefault: function(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.cancelBubble = true;
    }
  },
  stopPropagation: function(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.returnValue = false;
    }
  }
};
```

## 事件类型

### HTML5 事件

#### beforeunload

关于页面卸载前的自定义提示，目前只有 IE11-版本支持，可以通过在事件处理程序中 `return` 要返回的提示信息。

```js
window.addEventListener(
  "beforeunload",
  function(e) {
    return "are you sure？";
  },
  false
);
```

最新版本的 firefox、chrome、Microsft Edge 都已经不支持自定义提示，但是如果要打开系统提示，则必须要使用以下方式来跨浏览器支持：

```js
window.addEventListener(
  "beforeunload",
  function(e) {
    var message = "are you sure？";
    e.preventDefault(); //Edge required
    e.returnValue = message;
    return message;
  },
  false
);
```
