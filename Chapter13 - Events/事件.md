# 《JavaScript 高级程序设计》第十三章：事件

## 简介

JavaScript 与 HTML 的交互是通过“事件”实现的，它相当于两者的枢纽，建立起联接关系。

“事件”就是用户或浏览器自生执行的某种动作，例如用户点击(onclick)，浏览器的资源加载(onload)等，我们可以使用“事件侦听器(Listener)”来预定事件，以便事件发生时执行相应的代码，这种实现模式在软件工程中就被称之为“观察员模式”

“事件”最早出现与 `IE3`, `NetSapce Navigator 2`中，在 `IE4` 与 `NN4` 时 API 开始趋于相似，但直到 DOM2 级的事件模块才开始将其标准化为 DOM 事件。目前 IE9+版本已经完全实现了 DOM 事件的核心部分。

> 浏览器的事件系统除了 DOM 事件，还有 BOM 事件，但是由于 BOM 一直缺乏标准规范（HTML5 已经开始标准化），所以有时会跟 DOM 的某些事件在区分上并不十分清晰。

## 事件流

“事件流”描述的是事件被触发后在文档中的传播与接收的顺序，其中 IE 浏览器提出了“事件冒泡流”，NetSapce 提出了“事件捕获流”，它们是相反的概念

### 冒泡事件流

事件冒泡(bubbling)是 IE 提出的事件流。即事件从触发事件的目标元素起沿着 DOM 树层层向上传播至 `window` 为止，也就是说在此范围内的父元素都可以接收到触发的事件。

示意图：

### 捕获事件流

事件捕获(capturing)是 NetSpace 团队提出的。其思路是事件的触发由最顶层的元素 `window` 开始接收，然后再沿着 DOM 树层层传播至实际触发的目标元素为止。

示例图：

### DOM 事件流

DOM 事件流也是标准事件流，它有三阶段：“捕获阶段”、“目标阶段”、“冒泡阶段”。

- 捕获阶段：当一个事件被触发后，就会由 `window` 发出，然后沿着 DOM 树不断的层层向下传播，直到“目标元素”的父元素为止，这一过程就是“捕获阶段”。在捕获的过程中，所有经过的父节点都会触发这个事件，捕获阶段的任务就是建立事件传递的路线，而之后的冒泡阶段便会顺着这条路线再返回至 `window`。由于捕获阶段不会将事件传递到“目标元素”上，所以理论上事件捕获阶段不会触发目标阶段的事件。
- 目标阶段：当事件捕获阶段传递完毕后，下一个要传递的事件接收节点便是实际触发事件的目标元素节点，因此目标阶段就是捕获阶段传递到实际的目标元素的过程，目标阶段所触发的事件就是我们实际所需要触发的事件处理。如果在这一阶段阻止了冒泡，那么 DOM 事件流就会在这里中止。
- 冒泡阶段：目标阶段完成后，事件便会从目标元素的父元素开始沿着捕获阶段的路线以相反的方向从下向上返回最顶层的 `window` 对象。冒泡阶段可以看作是捕获阶段的逆传播。

由 DOM 事件流的传播机制我们可知，目标元素节点是无法同时指定冒泡阶段与捕获阶段的事件，因为目标元素节点的事件就是我们实际所需要触发的事件，它只会再 DOM 流的目标阶段才会被触发执行，而捕获与冒泡的事件都是目标元素的父级元素具有同类型事件时感知触发的，因此事件流的执行顺序是：父元素捕获阶段的事件 -> 当前（目标）元素的目标阶段事件 -> 父元素冒泡阶段的事件。

虽然我们无法为目标元素节点绑定多种事件流的事件，但是我们可以为其所有的父节点同时绑定多种事件流的事件。

```js
var btn = document.getElementById("btn");
btn.parentNode.onclcik = function() {
  alert("冒泡阶段");
};
btn.parentNode.addEventListener(
  "click",
  function() {
    alert("捕获阶段");
  },
  true
);
btn.onclick = function() {
  alert("目标阶段");
};
```

## 事件处理程序

“事件处理程序” 就是响应某个事件的函数或可执行的 JavaScript 语句，也可以称之为“事件侦听器”、“事件句柄”等。
“事件处理程序” 由两部分组成，一部分是“事件属性名”可以看作是“事件处理程序”的函数名，另一部分便是事件处理函数本身,用于事件触发时执行相应的动作。通常我们约定“事件处理程序”属性名是由前缀“on”加上具体的事件名组成，例如 click 事件的事件处理程序（事件属性名、事件句柄属性名）属性名就是 `onclick`，类似的还有 `onload`、`onmouseover` 等。在 DOM 事件体系中，这些事件属性名通常就是 HTML 标签的事件属性名或者 DOM 对象的事件属性名。

```html
<a onclick="alert(1)" onmouseover="alert('mouse')"></a>
```

```js
console.dir(document.body);

/*
{   
    ....
    onchange:null,
    onclick: ƒ onclick(event),
    onclose: null
    ....
}
*/
```

示意图：

“事件”是浏览器的特定动作，它可以被用户或浏览器自身触发，当一个事件被触发后，它便会去查找对应的事件处理程序属性有没有被赋值，如果有，便会执行该“事件处理程序”。
“事件”一直都是存在的，只不过对应的事件处理程序为 `null` ，因此就算事件被触发也不会进行任何操作，而我们常说的事件绑定，其实并不是真的为 DOM 元素或事件目标绑定事件，而是为其事件处理程序属性（事件属性、事件侦听器属性、事件句柄属性）赋值(事件处理函数)。

事件与事件处理程序关系示意图：

为“事件”指定事件处理程序的方式主要有三大类：事件属性赋值、标准的事件监听器、IE 专有的事件监听器，而“事件属性赋值”又可以分为两种：“HTML 事件处理程序” 和 “DOM0 级事件处理程序”。

### HTML 事件处理程序

某个元素支持的每种事件，都可以使用一个与其事件处理程序同名的 HTML 标签属性来指定（即通过标签属性来为对应的事件处理程序赋值）。

```html
<div onclick="javascript:alert('hello!')"></div>
```

在 HTML 中定义事件处理程序时，标签的事件处理程序属性会事先接收一个匿名函数作为实际的事件处理程序，然后将我们要赋值的事件处理函数或可执行的代码加入到这个匿名的函数内执行。

```html
<script>
  function showMessage(self) {
    console.log(this);
    console.log(self);
  }
</script>
<input type="button" name="button1" onclick="showMessage" />
<input type="button" name="button2" onclick="showMessage()" />
<input type="button" name="button3" onclick="showMessage(this)" />
```

单击上面的按钮，我们会发现 button1 根本不执行，而 button2 中打印的 this 指向的是 `window` ，而不是我们认为的当前 dom 对象，最后只有 button3 的执行符合我们的预期，但是使用方式并非我们所期望的形式，而原因就如上所述，我们指定的事件处理函数并没有真的作为事件处理程序来被事件执行，而是在一个匿名的事件处理程序中被调用执行。

```js
var button1 = document.getElementsByName("button1")[0];
var button2 = document.getElementsByName("button2")[0];
var button3 = document.getElementsByName("button3")[0];

//-------------------- RUN ----------------------------

console.dir(button1.onclick); //ƒ onclick(event) { showMessage}
console.dir(button2.onclick); //ƒ onclick(event) {showMessage()}
button3.click(); //<input type="button" name="button3" onclick="showMessage(this)" />
```

HTML 事件处理程序除了有一个容易让人误导的地方外，它还有一个特点，那就是其事件处理程序的作用域链会被 `with` 使用 `document` 对象进行延长，因此 HTML 中的事件处理程序不仅可以有权访问最顶层的 `window` 对象，还可以访问 `document` 对象中的方法或属性。

```html
<input type="button" name="button" onclick="alert(defaultView === window)" />
```

而且，如果当前元素是一个表单输入元素，那么其事件处理程序还会被 `with` 使用 `Form`（当前表单元素所处的 form 元素）对象来延长其作用域链，这样的好处就是我们可以直接在事件处理程序中使用 `name` 来获取同表单域下的其它表单输入元素。

```html
<form>
  <input name="username" />
  <input type="button" name="button" onclick="alert(username.value)" />
</form>
```

**HTML 中事件处理程序的特点：**

- 我们所指定的事件处理函数会被一个匿名的事件处理程序包裹执行。
- HTML 中的事件处理程序内其 `this` 指向的是当前 DOM 对象自身
- HTML 中的事件处理程序其作用域链会被 `with` 集合 `document` 或者表单对象进行延长。

> 虽然 HTML 事件处理程序有其独特点，但让 HTML 与 JavaScript 代码紧密耦合是其最大的缺陷，因此我们要避免使用，通常都是用于 demo 的验证。

### DOM0 级事件处理程序

DOM0 级事件处理程序是非标准的事件处理程序注册方式。这种方式出现于第四代 Web 浏览器中，现已经被所有浏览器支持，成为事实上通用的标准。
使用 DOM0 级指定事件处理程序就是将一个函数赋值给一个事件处理程序属性，因此对比 HTML 事件处理程序，我们指定的事件处理函数就是实际的事件处理程序，所以当一个函数被赋值给一个事件句柄属性后，其函数内部的 `this` 默认指向的就是事件目标对象自身。

```js
function showMessage() {
  console.log(this.tagName); //'BUTTON'
}
button.onclick = showMessage;
```

由于 DOM0 级指定事件处理程序的方式不支持自定义事件流，所以这种方式添加的事件处理程序只能在事件流的冒泡流阶段被处理。
删除 DOM0 级事件处理程序非常简单，只需要为所需的事件处理程序属性的值置为 null 即可。

```js
button.onclick = null;
```

> 同样的删除原理也可以用于 HTML 事件处理程序。

**DOM0 级事件处理程序特点：**

- 事件处理程序中的 this 默认指向的就是事件目标自身。
- 事件处理程序只能在事件流的冒泡流阶段被处理。

### DOM2 级事件处理程序

DOM2 级指定事件处理程序的方式是标准的事件监听器方式，它有两个方法分别是添加监听器 `addEventListener()` 和 移除监听器 `removeEventListener`，这两个方法是在 `EventTarget` 接口(构造函数)上定义的，因此所有的 DOM 节点都可以调用到这两个方法。

“事件监听器”函数需要传入三个参数，分别是事件名，作为事件处理程序的函数和一个布尔值。前两个参数不在赘述，而最后一个布尔值参数则用来指定事件处理程序是在事件流的那个阶段被执行，如果为 `true` 则表示在捕获阶段被执行，而如果为`false`，则表示在冒泡阶段被执行，默认值为 `false`。

“事件监听器”函数的优点不仅体现于可以指定事件处理程序在事件流中的执行阶段，还可以为一个事件指定多个事件处理程序，并在触发后按照顺序执行。

```js
var button = document.getElementById("btn");
button.addEventListener(
  "click",
  function() {
    alert(1);
  },
  false
);
button.addEventListener(
  "click",
  function() {
    alert(2);
  },
  false
);
```

使用 DOM2 级方式来指定事件处理程序虽然方便，但是移除事件处理程序时将会显得很麻烦，当使用 `removeEventListener()` 方法来移除上面两个事件处理程序，我们必须要保证向其传入的参数与添加时的参数完全相同(也就是说，如果参数是函数，则函数的引用也是相同的)，所以上面那种将匿名函数指定为事件除了程序函数的形式将永远也无法被删除。

**DOM2 级事件处理程序特点：**

- 可以自定义事件处理程序的执行阶段。
- 可以同时为一个事件添加多个事件处理程序。
- 事件处理程序内的 `this` 默认指向 DOM 对象自身
- 移除事件处理程序时传入的参数必须与添加时传入的参数完全相同。

### IE 事件处理程序

IE 中也实现了与 DOM2 级类似的两个方法： `attachEvent()` 和 `detachEvent()`，它们都接受相同的两个参数，分别是“事件处理程序属性名”和“事件处理函数”。
由于 IE8 以及更早期版本只支持事件冒泡，所以通过 `attachEvent()` 与 `detachEvent()` 方法指定的事件处理程序都会被添加到冒泡阶段执行。

```js
btn.attachEvent("onclick", function() {});
```

`attachEvent()`方法可以为一个事件添加多个事件处理程序，但是这些事件处理程序的执行顺序是不能确定的。还需要注意的是，通过 `attachEvent()` 方法指定的事件处理程序，其函数内的 `this` 默认指向的是 window,而非目标 DOM 某元素本身。

最后，与 DOM2 级删除事件处理程序的机制相同，当使用`detachEvent()`方法来删除某个事件处理程序时，必须要保证传入的参数与指定时的参数完全相同，也就是说上面那种指定的匿名函数形式的事件处理程序将永远无法被移除。

**IE 事件处理程序特点：**

- 指定时事件处理程序属性的名称是完整的事件属性名称。
- 可以支持为一个事件添加多个事件处理程序。
- 只支持指定冒泡阶段的事件处理程序。
- 指定的事件处理程序函数内部 `this` 默认指向的是 `window`，而非目标 DOM 元素本身。
- 删除时必须要传入与指定时完全相同的参数。

### 跨浏览器的事件处理程序。

通过使用能力检测的方式来为不同的浏览器选择合适的事件处理程序注册方式。
通常我们的优先级是 DOM2 级事件处理程序方式 -> IE 事件处理程序方式 -> DOM0 级事件处理程序方式。

```js
var eventUtil = {
  addEvent: function(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element["event_" + handler.name] = function(event)) {
        handler.call(element, event ||  window.event);
      };
      element.attachEvent("on" + type, element["event_" + handler.name]);
    } else {
      element["on" + type] = handler;
    }
  },
  removeEvent: function(element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, element["event_" + handler.name]);
    } else {
      element["on" + type] = null;
    }
  }
};
```

## 事件对象

### DOM 事件对象

当事件触发时会产生一个“事件对象(evnet)”，这个事件对象包含了所有与该事件相关的信息。包括触发事件的“当前元素(currentTarget)”、触发事件的“目标元素(target)”、“事件类型(type)”以及该事件类型特有的细节信息。

DOM 事件对象会作为事件处理程序的形参来传入到事件处理函数中。

```js
element.onclick = function(event) {
  console.log(event.type);
};
element.addEventListener("click", function(event) {
  console.log(event.type);
});
```

但如果是 HTML 事件处理程序方式，那么“事件对象”会保存在 `window` 窗口对象上，通过 `window.event` 属性我们便可以引用到该事件的“事件对象”。

```html
<input onclick="console.log(event)" />
```

下面是 DOM 事件对象常用的属性或方法：

|         属性/方法          |   取值   |                                                         说明                                                          |
| :------------------------: | :------: | :-------------------------------------------------------------------------------------------------------------------: |
|          bubbles           | Boolean  |                                                  该事件是否支持冒泡                                                   |
|        cancellabel         | Boolean  |                                              该事件是否可以取消默认行为                                               |
|       currentTarget        | Element  |                                        事件处理程序当前正在处理事件的那个元素                                         |
|      defaultPrevented      | Boolean  |                              是否已经调用了 `preventDefault()` 方法取消了事件的默认行为                               |
|           detail           | Integer  |                                                 与事件有关的细节信息                                                  |
|         eventPhase         | Integer  |                         该事件处于事件流中的阶段，1 表示捕获阶段、2 为目标阶段、3 为冒泡阶段                          |
|      preventDefault()      | Function |                                                  取消事件的默认行为                                                   |
| stopImmediatePropagation() | Function | 阻止事件流下一个冒泡或捕获阶段的事件处理程序，同时还会立即阻止当前元素后续同类型的事件多个事件处理程序。(DOM3 级新增) |
|     stopPropagation()      | Function |                                    阻止事件流下一个冒泡或捕获阶段的事件处理程序。                                     |
|           target           | Element  |                                                    事件的目标元素                                                     |
|          trusted           | Boolean  |                                      分别事件是浏览器中的事件还是用户自定义事件                                       |
|            type            |  String  |                                                       事件类别                                                        |
|            view            |  Object  |                                            事件对象对 `window` 对象的引用                                             |

> \*如果在事件处理程序中直接返回 `return false`，效果则等同于同时执行 `preventDefault()` 与 `stopPropagation()` 方法。

在阻止事件流的下一个冒泡或捕获阶段的事件处理程序的执行上，我们可选的方案有两个：`stopPropagation()` 与 `stopImmediatePropagation()` ，它们的区别在于后者不仅能阻止事件流的下一步捕获或冒泡的执行，还能阻止当前元素为同一个事件注册的多个后续执行的事件处理程序。

```js
element.addEventListener("click", function(e) {
  console.log("click1");
  e.stopPropagation(); // 执行该方法只会打印 click1 、click2。
  e.stopImmediatePropagation(); // 执行该方法只会打印 click1。
});

element.addEventListener("click", function(e) {
  console.log("click2");
});

document.body.addEventListener("click", function() {
  console.log("body click");
});
```

> 因此 `stopImmediatePropagation()` 方法在 DOM0 级方式的事件处理程序中基本无效，只能用于 DOM2 级注册事件处理程序的方式中。

在事件处理程序的内部 `this` 永远指向的 `currentTarget`，而 `target` 则是指触发事件的实际目标元素，由于目标元素就是事件流目标阶段的元素节点，所以当 `eventPhase` 为 2 时，`this`、`currentTarget`、`target` 三者时完全相同的。

```js
element.onclick = function(e) {
  if (e.eventPhase === 2) {
    console.log(this === e.currentTarget && this === e.target); //true
  }
};
```

最后，事件对象只会存在事件处理程序执行的期间，一旦事件处理程序执行完毕，那么事件对象就会被回收（究其原因还时在于事件对象时一个形参）。

### IE 事件对象

在 IE 浏览器内，不论是在 HTML 事件处理程序方式还是 DOM0 级事件处理程序的指定方式上，IE 独有的“事件对象”都是保存在 window 对象上，需要通过 `window.event` 进行引用，所以早期获取事件对象的兼容性写法如下所示：

```js
element.onclick = function(event) {
  var event = event || window.event;
};
```

这样对于支持标准 DOM 事件的浏览器中直接通过事件处理程序的参数获取事件对象，而 IE 浏览器则通过全局对象来获取引用。
对于使用 `attachEvent()` 方法指定的事件处理程序，其事件对象的获取与 DOM 事件对象的获取方式相同(可直接通过事件处理程序的参数来获取)。

```js
element.attachEvent("onclick", function(e) {
  console.log(e);
});
```

下面是 IE 事件对象常用的属性：

|     属性     |  取值   |                    说明                    |
| :----------: | :-----: | :----------------------------------------: |
| cancelBubble | Boolean |  是否阻止冒泡，如果赋值为 `true`表示阻止   |
| returnValue  | Boolean | 是否取消默认行为，赋值为 `false` 表示取消  |
|  srcElement  | Element | 获取实际的目标节点，类似于 `target` 属性。 |
|     type     | String  |                  事件类型                  |

在 IE 事件对象中 `event.cancelBubble = true` 等同于 `event.stopPropagation()` 方法，但由于 IE8 及更早的版本只支持事件冒泡，所以该属性无法像 `stopPropagation()` 方法那样还支持阻止事件捕获。

在 IE 事件对象中 `event.returnValue = false` 等同于 `event.preventDefault()` 方法，阻止事件默认的行为。

另外由于 `attachEvent()` 方法自身的缺陷，其注册的事件处理程序内部 `this` 指向的是 `window` 对象而非 DOM 事件对象中的 `currentTarget` 当前元素。

```js
element.attachEvent("onclick", function(e) {
  console.log(this === e.srcElement); // false
});
```

### 跨浏览器的事件对象

对大多数浏览器都支持的事件对象属性或方法进行封装。

```js
var eventUtil = {
  addEvent: function() {
    /*...*/
  },
  removeEvent: function() {
    /*...*/
  },
  getEvent: function(e) {
    return e || window.event;
  },
  getTarget: function(e) {
    return e.target || e.srcElement;
  },
  preventDefault: function(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.cancelBubble = true;
    }
  },
  stopPropagation: function(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.returnValue = false;
    }
  }
};
```

## 事件类型

根据触发条件的不同，事件可以分为以下几类：

- UI 事件
- 焦点事件
- 鼠标事件
- 键盘事件
- 文本事件
- 合成事件
- 变动事件
- HTML5 事件
- 设备事件

### UI 事件

UI 事件主要由 “HTML 事件”组成。

UI 事件主要用于保留在 DOM 事件规范出现之前，就已经以这种或那种形式存在着的事件，目的便是为了向后兼容。

常用的 UI 事件有：

- [x] load
- [x] unload
- [x] abort
- [x] error
- [x] select
- [x] resize
- [x] scroll

####load

`load` 事件会在大多数通过 HTTP 进行资源请求的载体上触发。例如页面及其资源加载完毕后在 `window`对象上触发；框架内的页面加载完毕后在 `iframe` 上触发；图像、脚本、样式加载完毕后在其对应的 `img`、`script`、`link` 标签上触发。

除了可以使用 DOM0 与 DOM1 级方式来为 `window` 对象指定`load`事件的事件处理程序外，还可以通过 HTML 事件处理程序方式为 `body` 元素的 `onload` 属性指定事件处理程序。

```html
<body onload="alert(event.target === document)"></body>
```

通常能在 `window` 上触发的事件，都可以在 `<body>` 元素上通过设置相应的属性进行指定。而事件对象的目标元素(target)则是 `document` 对象。

我们很少会使用 `load` 事件来判断网页整体的加载情况，因为它很慢总会等待所有请求资源加载完毕后才会触发。

`load` 事件被常用于网页局部资源的加载，例如“动态样式”、“动态脚本”、“图像预加载”等技术的应用上。

```js
function loadState(element) {
  if (element.addEventListener) {
    element.addEventListener("load", function(event) {
      alert(event.target);
    });
  } else if (window.attachEvent) {
    element.attachEvent("onload", function(event) {
      alert(event.target);
    });
  } else {
    element.onload = function(event) {
      var e = event || window.event;
      alert(e.target);
    };
  }
}
```

先定义一个统一的加载状态判断方法，接着开始使用 `loadState` 方法来判断外部脚本、外部样式的加载状态：

```js
function loadLink(element) {
  var link = document.createElement("link");
  link.rel = "stylesheet";
  link.type = "text/css";
  loadState(link);
  link.href = "example.css";
  document.head.appendChild(link);
}

function loadScript(element) {
  var script = document.createElement("script");
  script.type = "text/javascript";
  loadState(script);
  script.src = "example.js";
  document.head.appendChild(link);
```

对于脚本与样式而言只有设置了 `src` 或 `href` 属性并将对应元素加入(appendChild)到页面后，浏览器才会进行相关资源的下载，而图片只要设置了 `<img />` 元素的 `src` 属性无需加入到页面中就可以直接触发浏览器下载。

```js
function loadImg() {
  var img = document.createElement("img");
  loadState(img);
  document.body.appendChild(img);
  img.src = "example.jpg";
}
```

另外，DOM0 级还定义了一个 `Image` 接口（构造函数），可以用来快速实例一个 `img` 元素对象。

```js
var img = new Image();
```

利用 `<img/>` 这种只要设置 `src` 属性而无需添加到页面中渲染就可以触发加载请求的特性，常用于图片缓存以及站点访问量统计等方面。

####unload

与 `load` 相反 `unload` 会在页面被卸载后触发，触发页面卸载的动作有：“刷新页面”、“跳转链接”、“表单提交”、“关闭页面窗口”等。

为防止`unload`事件被滥用、大多数浏览器都会屏蔽`unload`事件处理程序中的异步请求以及浏览器原生的交互 UI 组件（alert、confirm 等），但通过下面的代码，我们还是可以直观了解 `unload` 事件的触发机制。

```js
alert(localStorage.getItem("unload"));
window.onunload = function() {
  localStorage.setItem("unload", 1);
};
```

> 当我们刷新页面、跳转链接、关闭窗口后，再次进入该页面且成功的弹出了本地缓存中的值，便说明了 `unload` 事件被成功触发了。

`unload` 事件的常用场景有：

- 清除引用、避免内存泄漏。
- 关闭页面时统计与收集用户的操作信息

由于浏览器大都会阻止 `unload`事件处理程序中的异步请求，因此我们必须要通过一些特殊的技巧绕过这些限制，早期的方案有：

1. 创建一个最长几秒钟的死循环，然后来发送请求，请求发送成功立即终止循环。
2. 在 `unload` 中创建一个图片并设置其 `src` 来延迟卸载以保证数据的发送，因为绝大多数用户代理会延迟卸载以保证图片的载入，所以数据可以在卸载事件中发送。
3. 创建一个同步的 `XMLHttpRequest` 请求。

总的来说，上面的几种方法都会或多或少降低下个页面的载入性能，好在 `W3C` 为 `navigator` 对象制定了一个 `sendBeacon()` 方法，可用以异步的向服务器发送信息且不影响下一个页面的加载。

```js
indow.addEventListener("unload", logData, false);

function logData() {
  navigator.sendBeacon("/log", analyticsData);
}
```

其中　`analyticsData` 就是在页面卸载的时候异步发送的数据，它可以是 ArrayBuffer、Blob、DOMString、FormData 等类型。

与 `load` 事件相同，我们不仅可以使用 DOM0 级以及 DOM2 级的方式来为 `window` 对象指定 `unload` 事件处理程序，还可以通过 HTML 事件处理程序方式为 `body` 元素的 `onunload`属性指定事件处理程序，且事件对象的目标元素为 `document` 。

对于一个简单的页面来说，其事件的生命周期大致的顺序为：`DOMContentLoaded -> onload -> onbeforeload -> onunload`

> 参考
>
> - https://zh.javascript.info/onload-ondomcontentloaded#windowonunload
> - https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon
> - https://w3c.github.io/beacon/#introduction

####abort
该事件会在外部资源还在加载时，由用户手动停止或网络中断等原因而导致内容没有加载完成时触发。
该事件被常用于 `img` 图片预加载时的判断。

```js
<img onabort="alert('您的图片加载中断，请重新尝试！')" />
```

####error
该事件会在 JS 代码执行错误、图片资源无法请求（地址不存在）、框架无法加载页面时触发。

```js
window.onerror = function(e) {
  console.log(e); //Uncaught error
};

throw "error";
```

使用 `error` 事件我们可以实现页面的错误分析、图片的预加载等。

####select
当用户选择文本框或多行文本框中的一个或多个字符时触发。

####resize
当浏览器窗口大小发生变化时触发，由于该事件触发频率过高，通常我们会在其事件处理程序中使用防抖以及节流来进行优化。

由于这个事件是在 `window` 窗口上触发，因此可以通过 HTML 事件处理程序方式为 `<body>` 元素的 `onresize` 属性指定事件处理程序。

```html
<body onresize="console.log(event)"></div>
```

####scroll

该事件会在事件目标对象存在滚动条且进行滚动时触发。`scroll` 事件可以用于存在滚动条的任何元素或对象上，例如 `window` 对象或可滚动的局部容器元素。

当我们为 `window` 对象指定 `scroll` 事件处理程序时，实际触发滚动的目标元素在“混杂模式”下是 `<body>` 元素，而在标准模式下则是 `<html>` 元素。我们可以通过滚动元素的 `scrollTop` 与 `scrollLeft` 属性来反应滚动的位置：

```js
window.onscroll = function(e) {
  var scrollingElement =
    document.scrollingElement || document.documentElement || document.body;
  console.log(scrollingElement.scrollTop);
};
```

由于 `scroll` 事件会被频繁的触发，所以我们在实际使用时最好要使用防抖、节流函数来进行优化。

因为可以在 `window` 上触发 `scroll` 事件，所以也可以通过 HTML 事件处理程序方式在 `<body>`元素 上为 `onscroll` 属性设置滚动事件处理程序。

滚动条事件除了可以通过鼠标滚轮来触发，还可以通过以下方式进行触发：

1. 通过方向键以及空格键
2. 使用可以改变滚动条位置的属性或方法，例如：`scrollTop`，`scrollBy()`等。

### 焦点事件

焦点事件会在页面元素获得或失去焦点时触发，常用的的焦点事件如下：

- [x] focus : 当元素获得焦点时触发，该事件不会冒泡，但支持捕获。
- [x] foucsin : 当元素获得焦点时触发，该事件与 `focus` 等价，但支持冒泡。
- [x] blur : 当元素失去焦点时触发，该事件不会冒泡，但支持捕获。
- [x] focusout : 当元素失去焦点时触发，该事件与 `blur` 等价，但支持冒泡。

```html
<body>
  <input />
  <script>
    document.addEventListener("foucs", function() {
      console.log("focus");
    });
    document.addEventListener("focusin", function() {
      console.log("focusin");
    });
    document.addEventListener("blur", function() {
      console.log("blur");
    });
    document.addEventListener("focusout", function() {
      console.log("focusout");
    });
  </script>
</body>
```

在上面的例子中，因为 `focus`与 `blur` 不支持冒泡。所以当 `<input />` 获得或失去焦点时只会触发支持冒泡的 `foucsin` 与 `focusout`事件。

```js
var input = document.querySelector("input");
input.addEventListener("focusin", function(e) {
  console.log("focusin");
});
input.addEventListener("focus", function(e) {
  console.log("focus");
});

input.addEventListener("focusout", function(e) {
  console.log("focusout");
});
input.addEventListener("blur", function(e) {
  console.log("blur");
});
```

在这个例子中，我们可以获知焦点事件的触发顺序依次是：`focus` -> `focusin` -> `blur` -> `focusout`。可以看出支持冒泡的焦点事件会最后触发。

使用“焦点事件”结合 HTML5 DOM 扩展中的 `document.activeElement` 属性以及　`document.hasFocus()` 方法，我们可以知晓用户再页面上的行踪。

### 鼠标事件

鼠标是 PC 端 WEB 应用的主要定位设备，当我们移动鼠标、点击鼠标按钮、拨动鼠标滚动等都可以触发相应的鼠标事件。

常用的鼠标事件有（只有前 9 个属于 DOM 事件规范定义）：

- [x] mousedown
- [x] mouseup
- [x] click
- [x] dbclick
- [x] mouseover
- [x] mouseout
- [x] mousemove
- [x] mouseenter
- [x] mouseleave
- [x] mousewheel

鼠标事件主要可以划分为三大类：“鼠标点击”、“鼠标移动”、“鼠标滚轮滚动”。

#### 鼠标点击

鼠标的点击事件主要有：

- mousedown : 按下鼠标的任意键触发，该事件不能通过键盘触发。
- mouseup : 释放按下的鼠标按钮时触发，该事件不能通过键盘触发。
- click : 单击鼠标的主按键（一般时左边的按钮）时触发，对于一些特别的 HTML 标签，也可以在获取焦点时，通过键盘的 Enter 键或空格键触发 `click` 事件。
- dbclick : 双击鼠标主按键时触发，该事件不能通过键盘触发。

鼠标点击事件的触发顺序如下：

```js
var btn = document.querySelector("button");
btn.onmousedown = function(event) {
  console.log("mousedown");
};
btn.onmouseup = function(event) {
  console.log("mouseup");
};
btn.onclick = function(event) {
  console.log("click");
};
btn.ondblclick = function(event) {
  console.log("dbclick");
};

/**
* mousedown
* mouseup
* click
* mousedown
* mouseup
* click
* dbclick
* /
```

从中我们可以看出，`click` 事件的触发流程是鼠标的主按钮被按下(mousedown)然后又松开(mouseup)的过程，而 `dbclick` 则是整个 `click` 流程触发两次时触发。不难得出 `mousedown` 触发最快，但在一些用户代理中并不能保证被触发，而 `dbclick` 不会在移动端浏览器触发，反而会在双击后放大浏览器窗口，对于 PC 端而言，`dbclick` 也不能通过键盘的 `enter` 键触发，因此不适用与绑定一些重要的操作，反而 `click` 事件可以再元素获得焦点时通过键盘触发，因此在 PC 端的点击事件首先采用的应该是 `click`，但 `click` 应用在移动端时，在 IOS 系统下会有 200ms 延迟的缺陷。

#### 鼠标移动

- mouseover : 当鼠标指针移动到某个元素上时触发，该事件支持冒泡。
- mouseout : 当鼠标指针从某个元素上移出时触发，该事件支持冒泡。
- mousemove : 当鼠标指针在某个元素上来回移动时触发，该事件支持冒泡。
- mouseenter : 当鼠标指针在某个元素上时触发，这个事件不支持冒泡，而且将鼠标移动到当前元素的后代元素上再移回来也不会触发移入事件。
- mouseleave : 当鼠标指针从某个元素上离开时触发，这个事件不支持冒泡，而且将鼠标移动到当前元素的后代元素上也不会触发移出事件。

我们必须要注意，鼠标指针在某个元素上的移入/移出是有两种情况存在：一种就是从元素的外部移入，也可能是从当前元素的后代元素中移入回来；另一种则是从当前元素移出到同级的或顶层的其它元素，也可能是在当前元素内部移出到某个后代元素上。

```htm
<div><p></p></div>
```

```js
var div = document.querySelector("div");
div.addEventListener("mouseenter", function() {
  console.log("div");
});
```

此时，将鼠标从外部移入到 `div` 中，会触发 `mouseenter` 事件，但是将鼠标在 `div` 内部移入到 `p` 元素上，再移回便不会触发 `mouseenter` 事件。

#### 鼠标滚轮

鼠标滚动事件会在拨动鼠标中间的滚轮时触发。在早期 IE 与 Chrome 共同私有实现了一个 “mouseWheel”事件，而 Firefox 则单独实现了一个 `DOMMouseScroll`事件,到了后期 W3C 则标准化了一个 `wheel` 的鼠标滚轮事件，因此要跨浏览器使用鼠标滚轮事件，则需要使用下面的方式进行指定：

```js
function wheel(e) {
  console.log(e);
}

document.addEventListener("mousewheel", wheel);
document.addEventListener("DOMMouseScroll", wheel);
document.addEventListener("wheel", wheel);
```

在 `wheel` 与 `mouseWheel` 事件中可以通过 `wheelDelta` 属性获取鼠标滚轮滚动的方向（上或下），而在 `DOMMouseScroll` 中则通过 `detail` 属性来获取方向，下面是它们的兼容性处理：

```js
function getDirection(wheelDelta) {
  return wheelDelta >= 0 ? "up" : "down";
}
document.addEventListener("mousewheel", function(e) {
  console.log(getDirection(e.wheelDelta));
});
document.addEventListener("DOMMouseScroll", function(e) {
  console.log(getDirection(-e.detail));
});
```

鼠标滚轮事件相比于滚动条事件(scroll)，滚动条事件只有目标元素存在滚动条才会被触发，并且在滚动的时候，先触发滚轮事件，然后滚动条滚动，最后触发滚动条事件。

#### 鼠标位置

鼠标位置反应了鼠标事件发生时，鼠标指针所处用户代理的水平与垂直坐标位置，基于参考对象的不同，可以分为以下几种鼠标位置：

**偏移量坐标位置**
`event.offsetX` 与 `event.offsetY` 返回鼠标指针相对于目标元素(target)的 x，y 坐标。

**客户区坐标位置**
`event.clientX` 与 `event.clientY` 返回鼠标指针所处浏览器窗口(浏览器视口-viewport)客户区的 x，y 坐标。

**页面坐标位置**
`event.pageX` 与 `event.pageY` 返回鼠标指针所处整个页面的 x，y 坐标。

通常当页面没有滚动的时候，`pageX`，`pageY` 等同于 `clientX` 与 `clientY`。IE8 及以下版本不支持 `pageX`与`pageY`属性，因此便需要通过 `clientX`，`clientY`结合 `scrollTop`,`scrollLeft` 进行模拟。

```js
document.body.onclick = function(event) {
  var event = event || window.event;
  var pageX = event.pageX;
  var pageY = event.pageY;
  var scrollElement =
    document.scrollingElement || document.documentElement || document.body;

  if (pageX === undefined) {
    pageX = event.clientX + scrollElement.scrollLeft;
  }

  if (pageY === undefined) {
    pageY == event.clientY + scrollElement.scrollTop;
  }

  console.log(pageX, pageY);
};
```

**浏览器坐标位置**
`event.x` 与 `event.y` 可以返回鼠标指针所处浏览器的 x，y 坐标。

> 要区分 clientX 是鼠标所处浏览器视口(viewport)的位置，而 x 则返回的是鼠标指针位于整个浏览器中的位置。

**屏幕坐标位置**
`event.screenX` 与 `event.screenY` 返回鼠标指针所处电脑屏幕的 x，y 坐标。

最后，我们可以通过一张图来直观了解这些鼠标位置的实际含义：

### 修饰键

在鼠标事件与键盘事件组合使用的场景中，我们可以通过事件对象的“修饰键”属性来获取键盘中某些按键的状态。例如，按住 `ctrl` 键再单击鼠标的操作，其中 `ctrl` 键对应的修饰键属性便是 `ctrlKey`。

“修饰键”属性用来反应某些按键的状态，返回值为布尔值，如果相应的键被按下，则值为 `true`，否则值为 `false`。

鼠标事件所支持的修饰键属性如下：

- ctrlKey : `ctrl` 键是否按下
- altKey :`alt` 键是否按下
- shiftKey : `shift` 键是否按下
- metaKey : 在 window 中为 `window` 键，在苹果机中为 `command` 键。

当鼠标事件发生时，通过检测以上几个修饰键属性的值便可以确定用户是否同时按下了相应的按键。

```js
document.body.onclick = function(e) {
  var event = e || window.event;
  var keys = [];

  if (event.shiftKey) {
    keys.push("shift");
  }
  if (event.altKey) {
    keys.push("altKey");
  }
  if (event.ctrlKey) {
    keys.push("ctrl");
  }
  if (event.metaKey) {
    keys.push("meta");
  }

  console.log(keys.join());
};
```

需要注意的是 Chrome、Firefox 都支持这四个修饰键属性，但是 IE 不支持 `metaKey`，但支持其它三个修饰键属性。

#### 相关元素

“相关元素(relatedElement)”，

#### 鼠标按钮

复合事件
由于输入法编辑器(IME)会截取键盘事件，获取用户输入的多个字符，然后输出最终的结果字符，因此我们便需要定义一个可以检测和处理这种输入而设计的事件 - “复合事件(compostion)”。

### HTML5 事件

contextmenu 属于鼠标事件，所以其事件对象包含鼠标相关的信息，例如指针的坐标。

```js
document.addEventListener("contextmenu", function(e) {
  var contextmenu = document.getElementById("contextmenu");
  if (contextmenu) {
    contextmenu.parentNode.removeChild(contextmenu);
  }

  var oDiv = document.createElement("div");
  oDiv.id = "contextmenu";
  oDiv.innerText = "contextmenu";
  oDiv.style.cssText =
    "position:absolute;padding:10;background:#ccc;border:1px solid #aaa";
  oDiv.style.left = e.clientX + "px";
  oDiv.style.top = e.clientY + "px";
  document.body.appendChild(oDiv);
  e.preventDefault();
});

document.addEventListener("click", function() {
  var contextmenu = document.getElementById("contextmenu");
  if (contextmenu) {
    contextmenu.parentNode.removeChild(contextmenu);
  }
});
```

其触发流程为 - mousedown -> mouseup -> contextmenu。

#### beforeunload

关于页面卸载前的自定义提示，目前只有 IE11-版本支持，可以通过在事件处理程序中 `return` 要返回的提示信息。

```js
window.addEventListener(
  "beforeunload",
  function(e) {
    return "are you sure？";
  },
  false
);
```

最新版本的 firefox、chrome、Microsft Edge 都已经不支持自定义提示，但是如果要打开系统提示，则必须要使用以下方式来跨浏览器支持：

```js
window.addEventListener(
  "beforeunload",
  function(e) {
    var message = "are you sure？";
    e.preventDefault(); //Edge required
    e.returnValue = message;
    return message;
  },
  false
);
```

参考：
https://zh.javascript.info/onload-ondomcontentloaded
