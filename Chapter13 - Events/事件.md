# 《JavaScript 高级程序设计》第十三章：事件

## 简介

JavaScript 与 HTML 的交互是通过“事件”实现的，它相当于两者的枢纽，建立起联接关系。

“事件”就是用户或浏览器自生执行的某种动作，例如用户点击(onclick)，浏览器的资源加载(onload)等，我们可以使用“事件侦听器(Listener)”来预定事件，以便事件发生时执行相应的代码，这种实现模式在软件工程中就被称之为“观察员模式”

“事件”最早出现与 `IE3`, `NetSapce Navigator 2`中，在 `IE4` 与 `NN4` 时 API 开始趋于相似，但直到 DOM2 级的事件模块才开始将其标准化为 DOM 事件。目前 IE9+版本已经完全实现了 DOM 事件的核心部分。

> 浏览器的事件系统除了 DOM 事件，还有 BOM 事件，但是由于 BOM 一直缺乏标准规范（HTML5 已经开始标准化），所以有时会跟 DOM 的某些事件在区分上并不十分清晰。

## 事件流

“事件流”描述的是事件被触发后在文档中的传播与接收的顺序，其中 IE 浏览器提出了“事件冒泡流”，NetSapce 提出了“事件捕获流”，它们是相反的概念

### 冒泡事件流

事件冒泡(bubbling)是 IE 提出的事件流。即事件从触发事件的目标元素起沿着 DOM 树层层向上传播至 `window` 为止，也就是说在此范围内的父元素都可以接收到触发的事件。

示意图：

### 捕获事件流

事件捕获(capturing)是 NetSpace 团队提出的。其思路是事件的触发由最顶层的元素 `window` 开始接收，然后再沿着 DOM 树层层传播至实际触发的目标元素为止。

示例图：

### DOM 事件流

DOM 事件流也是标准事件流，它有三阶段：“捕获阶段”、“目标阶段”、“冒泡阶段”。

- 捕获阶段：当一个事件被触发后，就会由 `window` 发出，然后沿着 DOM 树不断的层层向下传播，直到“目标元素”的父元素为止，这一过程就是“捕获阶段”。在捕获的过程中，所有经过的父节点都会触发这个事件，捕获阶段的任务就是建立事件传递的路线，而之后的冒泡阶段便会顺着这条路线再返回至 `window`。由于捕获阶段不会将事件传递到“目标元素”上，所以理论上事件捕获阶段不会触发目标阶段的事件。
- 目标阶段：当事件捕获阶段传递完毕后，下一个要传递的事件接收节点便是实际触发事件的目标元素节点，因此目标阶段就是捕获阶段传递到实际的目标元素的过程，目标阶段所触发的事件就是我们实际所需要触发的事件处理。如果在这一阶段阻止了冒泡，那么 DOM 事件流就会在这里中止。
- 冒泡阶段：目标阶段完成后，事件便会从目标元素的父元素开始沿着捕获阶段的路线以相反的方向从下向上返回最顶层的 `window` 对象。冒泡阶段可以看作是捕获阶段的逆传播。

由 DOM 事件流的传播机制我们可知，目标元素节点是无法同时指定冒泡阶段与捕获阶段的事件，因为目标元素节点的事件就是我们实际所需要触发的事件，它只会再 DOM 流的目标阶段才会被触发执行，而捕获与冒泡的事件都是目标元素的父级元素具有同类型事件时感知触发的，因此事件流的执行顺序是：父元素捕获阶段的事件 -> 当前（目标）元素的目标阶段事件 -> 父元素冒泡阶段的事件。

虽然我们无法为目标元素节点绑定多种事件流的事件，但是我们可以为其所有的父节点同时绑定多种事件流的事件。

```js
var btn = document.getElementById("btn");
btn.parentNode.onclcik = function() {
  alert("冒泡阶段");
};
btn.parentNode.addEventListener(
  "click",
  function() {
    alert("捕获阶段");
  },
  true
);
btn.onclick = function() {
  alert("目标阶段");
};
```

## 事件处理程序

“事件处理程序” 就是响应某个事件的函数或可执行的 JavaScript 语句，也可以称之为“事件侦听器”、“事件句柄”等。
“事件处理程序” 由两部分组成，一部分是“事件属性名”可以看作是“事件处理程序”的函数名，另一部分便是事件处理函数本身,用于事件触发时执行相应的动作。通常我们约定“事件处理程序”属性名是由前缀“on”加上具体的事件名组成，例如 click 事件的事件处理程序（事件属性名、事件句柄属性名）属性名就是 `onclick`，类似的还有 `onload`、`onmouseover` 等。在 DOM 事件体系中，这些事件属性名通常就是 HTML 标签的事件属性名或者 DOM 对象的事件属性名。

```html
<a onclick="alert(1)" onmouseover="alert('mouse')"></a>
```

```js
console.dir(document.body);

/*
{   
    ....
    onchange:null,
    onclick: ƒ onclick(event),
    onclose: null
    ....
}
*/
```

示意图：

“事件”是浏览器的特定动作，它可以被用户或浏览器自身触发，当一个事件被触发后，它便会去查找对应的事件处理程序属性有没有被赋值，如果有，便会执行该“事件处理程序”。
“事件”一直都是存在的，只不过对应的事件处理程序为 `null` ，因此就算事件被触发也不会进行任何操作，而我们常说的事件绑定，其实并不是真的为 DOM 元素或事件目标绑定事件，而是为其事件处理程序属性（事件属性、事件侦听器属性、事件句柄属性）赋值(事件处理函数)。

事件与事件处理程序关系示意图：

为“事件”指定事件处理程序的方式主要有三大类：事件属性赋值、标准的事件监听器、IE 专有的事件监听器，而“事件属性赋值”又可以分为两种：“HTML 事件处理程序” 和 “DOM0 级事件处理程序”。

### HTML 事件处理程序

某个元素支持的每种事件，都可以使用一个与其事件处理程序同名的 HTML 标签属性来指定（即通过标签属性来为对应的事件处理程序赋值）。

```html
<div onclick="javascript:alert('hello!')"></div>
```

在 HTML 中定义事件处理程序时，标签的事件处理程序属性会事先接收一个匿名函数作为实际的事件处理程序，然后将我们要赋值的事件处理函数或可执行的代码加入到这个匿名的函数内执行。

```html
<script>
  function showMessage(self) {
    console.log(this);
    console.log(self);
  }
</script>
<input type="button" name="button1" onclick="showMessage" />
<input type="button" name="button2" onclick="showMessage()" />
<input type="button" name="button3" onclick="showMessage(this)" />
```

单击上面的按钮，我们会发现 button1 根本不执行，而 button2 中打印的 this 指向的是 `window` ，而不是我们认为的当前 dom 对象，最后只有 button3 的执行符合我们的预期，但是使用方式并非我们所期望的形式，而原因就如上所述，我们指定的事件处理函数并没有真的作为事件处理程序来被事件执行，而是在一个匿名的事件处理程序中被调用执行。

```js
var button1 = document.getElementsByName("button1")[0];
var button2 = document.getElementsByName("button2")[0];
var button3 = document.getElementsByName("button3")[0];

//-------------------- RUN ----------------------------

console.dir(button1.onclick); //ƒ onclick(event) { showMessage}
console.dir(button2.onclick); //ƒ onclick(event) {showMessage()}
button3.click(); //<input type="button" name="button3" onclick="showMessage(this)" />
```

HTML 事件处理程序除了有一个容易让人误导的地方外，它还有一个特点，那就是其事件处理程序的作用域链会被 `with` 使用 `document` 对象进行延长，因此 HTML 中的事件处理程序不仅可以有权访问最顶层的 `window` 对象，还可以访问 `document` 对象中的方法或属性。

```html
<input type="button" name="button" onclick="alert(defaultView === window)" />
```

而且，如果当前元素是一个表单输入元素，那么其事件处理程序还会被 `with` 使用 `Form`（当前表单元素所处的 form 元素）对象来延长其作用域链，这样的好处就是我们可以直接在事件处理程序中使用 `name` 来获取同表单域下的其它表单输入元素。

```html
<form>
  <input name="username" />
  <input type="button" name="button" onclick="alert(username.value)" />
</form>
```

**HTML 中事件处理程序的特点：**

- 我们所指定的事件处理函数会被一个匿名的事件处理程序包裹执行。
- HTML 中的事件处理程序内其 `this` 指向的是当前 DOM 对象自身
- HTML 中的事件处理程序其作用域链会被 `with` 集合 `document` 或者表单对象进行延长。

> 虽然 HTML 事件处理程序有其独特点，但让 HTML 与 JavaScript 代码紧密耦合是其最大的缺陷，因此我们要避免使用，通常都是用于 demo 的验证。

### DOM0 级事件处理程序

DOM0 级事件处理程序是非标准的事件处理程序注册方式。这种方式出现于第四代 Web 浏览器中，现已经被所有浏览器支持，成为事实上通用的标准。
使用 DOM0 级指定事件处理程序就是将一个函数赋值给一个事件处理程序属性，因此对比 HTML 事件处理程序，我们指定的事件处理函数就是实际的事件处理程序，所以当一个函数被赋值给一个事件句柄属性后，其函数内部的 `this` 默认指向的就是事件目标对象自身。

```js
function showMessage() {
  console.log(this.tagName); //'BUTTON'
}
button.onclick = showMessage;
```

由于 DOM0 级指定事件处理程序的方式不支持自定义事件流，所以这种方式添加的事件处理程序只能在事件流的冒泡流阶段被处理。
删除 DOM0 级事件处理程序非常简单，只需要为所需的事件处理程序属性的值置为 null 即可。

```js
button.onclick = null;
```

> 同样的删除原理也可以用于 HTML 事件处理程序。

**DOM0 级事件处理程序特点：**

- 事件处理程序中的 this 默认指向的就是事件目标自身。
- 事件处理程序只能在事件流的冒泡流阶段被处理。

### DOM2 级事件处理程序

DOM2 级指定事件处理程序的方式是标准的事件监听器方式，它有两个方法分别是添加监听器 `addEventListener()` 和 移除监听器 `removeEventListener`，这两个方法是在 `EventTarget` 接口(构造函数)上定义的，因此所有的 DOM 节点都可以调用到这两个方法。

“事件监听器”函数需要传入三个参数，分别是事件名，作为事件处理程序的函数和一个布尔值。前两个参数不在赘述，而最后一个布尔值参数则用来指定事件处理程序是在事件流的那个阶段被执行，如果为 `true` 则表示在捕获阶段被执行，而如果为`false`，则表示在冒泡阶段被执行，默认值为 `false`。

“事件监听器”函数的优点不仅体现于可以指定事件处理程序在事件流中的执行阶段，还可以为一个事件指定多个事件处理程序，并在触发后按照顺序执行。

```js
var button = document.getElementById("btn");
button.addEventListener(
  "click",
  function() {
    alert(1);
  },
  false
);
button.addEventListener(
  "click",
  function() {
    alert(2);
  },
  false
);
```

使用 DOM2 级方式来指定事件处理程序虽然方便，但是移除事件处理程序时将会显得很麻烦，当使用 `removeEventListener()` 方法来移除上面两个事件处理程序，我们必须要保证向其传入的参数与添加时的参数完全相同(也就是说，如果参数是函数，则函数的引用也是相同的)，所以上面那种将匿名函数指定为事件除了程序函数的形式将永远也无法被删除。

**DOM2 级事件处理程序特点：**

- 可以自定义事件处理程序的执行阶段。
- 可以同时为一个事件添加多个事件处理程序。
- 事件处理程序内的 `this` 默认指向 DOM 对象自身
- 移除事件处理程序时传入的参数必须与添加时传入的参数完全相同。

### IE 事件处理程序

IE 中也实现了与 DOM2 级类似的两个方法： `attachEvent()` 和 `detachEvent()`，它们都接受相同的两个参数，分别是“事件处理程序属性名”和“事件处理函数”。
由于 IE8 以及更早期版本只支持事件冒泡，所以通过 `attachEvent()` 与 `detachEvent()` 方法指定的事件处理程序都会被添加到冒泡阶段执行。

```js
btn.attachEvent("onclick", function() {});
```

`attachEvent()`方法可以为一个事件添加多个事件处理程序，但是这些事件处理程序的执行顺序是不能确定的。还需要注意的是，通过 `attachEvent()` 方法指定的事件处理程序，其函数内的 `this` 默认指向的是 window,而非目标 DOM 某元素本身。

最后，与 DOM2 级删除事件处理程序的机制相同，当使用`detachEvent()`方法来删除某个事件处理程序时，必须要保证传入的参数与指定时的参数完全相同，也就是说上面那种指定的匿名函数形式的事件处理程序将永远无法被移除。

**IE 事件处理程序特点：**

- 指定时事件处理程序属性的名称是完整的事件属性名称。
- 可以支持为一个事件添加多个事件处理程序。
- 只支持指定冒泡阶段的事件处理程序。
- 指定的事件处理程序函数内部 `this` 默认指向的是 `window`，而非目标 DOM 元素本身。
- 删除时必须要传入与指定时完全相同的参数。

### 跨浏览器的事件处理程序。

通过使用能力检测的方式来为不同的浏览器选择合适的事件处理程序注册方式。
通常我们的优先级是 DOM2 级事件处理程序方式 -> IE 事件处理程序方式 -> DOM0 级事件处理程序方式。

```js
var eventUtil = {
  addEvent: function(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element["event_" + handler.name] = function(event)) {
        handler.call(element, event ||  window.event);
      };
      element.attachEvent("on" + type, element["event_" + handler.name]);
    } else {
      element["on" + type] = handler;
    }
  },
  removeEvent: function(element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, element["event_" + handler.name]);
    } else {
      element["on" + type] = null;
    }
  }
};
```

## 事件对象

### DOM 事件对象

当事件触发时会产生一个“事件对象(evnet)”，这个事件对象包含了所有与该事件相关的信息。包括触发事件的“当前元素(currentTarget)”、触发事件的“目标元素(target)”、“事件类型(type)”以及该事件类型特有的细节信息。

DOM 事件对象会作为事件处理程序的形参来传入到事件处理函数中。

```js
element.onclick = function(event) {
  console.log(event.type);
};
element.addEventListener("click", function(event) {
  console.log(event.type);
});
```

但如果是 HTML 事件处理程序方式，那么“事件对象”会保存在 `window` 窗口对象上，通过 `window.event` 属性我们便可以引用到该事件的“事件对象”。

```html
<input onclick="console.log(event)" />
```

下面是 DOM 事件对象常用的属性或方法：

|         属性/方法          |   取值   |                                                         说明                                                          |
| :------------------------: | :------: | :-------------------------------------------------------------------------------------------------------------------: |
|          bubbles           | Boolean  |                                                  该事件是否支持冒泡                                                   |
|        cancellabel         | Boolean  |                                              该事件是否可以取消默认行为                                               |
|       currentTarget        | Element  |                                        事件处理程序当前正在处理事件的那个元素                                         |
|      defaultPrevented      | Boolean  |                              是否已经调用了 `preventDefault()` 方法取消了事件的默认行为                               |
|           detail           | Integer  |                                                 与事件有关的细节信息                                                  |
|         eventPhase         | Integer  |                         该事件处于事件流中的阶段，1 表示捕获阶段、2 为目标阶段、3 为冒泡阶段                          |
|      preventDefault()      | Function |                                                  取消事件的默认行为                                                   |
| stopImmediatePropagation() | Function | 阻止事件流下一个冒泡或捕获阶段的事件处理程序，同时还会立即阻止当前元素后续同类型的事件多个事件处理程序。(DOM3 级新增) |
|     stopPropagation()      | Function |                                    阻止事件流下一个冒泡或捕获阶段的事件处理程序。                                     |
|           target           | Element  |                                                    事件的目标元素                                                     |
|          trusted           | Boolean  |                                      分别事件是浏览器中的事件还是用户自定义事件                                       |
|            type            |  String  |                                                       事件类别                                                        |
|            view            |  Object  |                                            事件对象对 `window` 对象的引用                                             |

> \*如果在事件处理程序中直接返回 `return false`，效果则等同于同时执行 `preventDefault()` 与 `stopPropagation()` 方法。

在阻止事件流的下一个冒泡或捕获阶段的事件处理程序的执行上，我们可选的方案有两个：`stopPropagation()` 与 `stopImmediatePropagation()` ，它们的区别在于后者不仅能阻止事件流的下一步捕获或冒泡的执行，还能阻止当前元素为同一个事件注册的多个后续执行的事件处理程序。

```js
element.addEventListener("click", function(e) {
  console.log("click1");
  e.stopPropagation(); // 执行该方法只会打印 click1 、click2。
  e.stopImmediatePropagation(); // 执行该方法只会打印 click1。
});

element.addEventListener("click", function(e) {
  console.log("click2");
});

document.body.addEventListener("click", function() {
  console.log("body click");
});
```

> 因此 `stopImmediatePropagation()` 方法在 DOM0 级方式的事件处理程序中基本无效，只能用于 DOM2 级注册事件处理程序的方式中。

在事件处理程序的内部 `this` 永远指向的 `currentTarget`，而 `target` 则是指触发事件的实际目标元素，由于目标元素就是事件流目标阶段的元素节点，所以当 `eventPhase` 为 2 时，`this`、`currentTarget`、`target` 三者时完全相同的。

```js
element.onclick = function(e) {
  if (e.eventPhase === 2) {
    console.log(this === e.currentTarget && this === e.target); //true
  }
};
```

最后，事件对象只会存在事件处理程序执行的期间，一旦事件处理程序执行完毕，那么事件对象就会被回收（究其原因还时在于事件对象时一个形参）。

### IE 事件对象

在 IE 浏览器内，不论是在 HTML 事件处理程序方式还是 DOM0 级事件处理程序的指定方式上，IE 独有的“事件对象”都是保存在 window 对象上，需要通过 `window.event` 进行引用，所以早期获取事件对象的兼容性写法如下所示：

```js
element.onclick = function(event) {
  var event = event || window.event;
};
```

这样对于支持标准 DOM 事件的浏览器中直接通过事件处理程序的参数获取事件对象，而 IE 浏览器则通过全局对象来获取引用。
对于使用 `attachEvent()` 方法指定的事件处理程序，其事件对象的获取与 DOM 事件对象的获取方式相同(可直接通过事件处理程序的参数来获取)。

```js
element.attachEvent("onclick", function(e) {
  console.log(e);
});
```

下面是 IE 事件对象常用的属性：

|     属性     |  取值   |                    说明                    |
| :----------: | :-----: | :----------------------------------------: |
| cancelBubble | Boolean |  是否阻止冒泡，如果赋值为 `true`表示阻止   |
| returnValue  | Boolean | 是否取消默认行为，赋值为 `false` 表示取消  |
|  srcElement  | Element | 获取实际的目标节点，类似于 `target` 属性。 |
|     type     | String  |                  事件类型                  |

在 IE 事件对象中 `event.cancelBubble = true` 等同于 `event.stopPropagation()` 方法，但由于 IE8 及更早的版本只支持事件冒泡，所以该属性无法像 `stopPropagation()` 方法那样还支持阻止事件捕获。

在 IE 事件对象中 `event.returnValue = false` 等同于 `event.preventDefault()` 方法，阻止事件默认的行为。

另外由于 `attachEvent()` 方法自身的缺陷，其注册的事件处理程序内部 `this` 指向的是 `window` 对象而非 DOM 事件对象中的 `currentTarget` 当前元素。

```js
element.attachEvent("onclick", function(e) {
  console.log(this === e.srcElement); // false
});
```

### 跨浏览器的事件对象

对大多数浏览器都支持的事件对象属性或方法进行封装。

```js
var eventUtil = {
  addEvent: function() {
    /*...*/
  },
  removeEvent: function() {
    /*...*/
  },
  getEvent: function(e) {
    return e || window.event;
  },
  getTarget: function(e) {
    return e.target || e.srcElement;
  },
  preventDefault: function(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.cancelBubble = true;
    }
  },
  stopPropagation: function(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.returnValue = false;
    }
  }
};
```

## 事件类型

事件根据触发条件的不同，可以分为以下几类事件：

- UI 事件
- 焦点事件
- 鼠标事件
- 键盘事件
- 文本事件
- 合成事件
- 变动事件
- HTML5 事件
- 设备事件

### UI 事件

UI 事件主要由 HTML 事件组成。

UI 事件主要用于保留在 DOM 事件规范出现之前，就已经以这种或那种形式存在着的事件，目的便是为了向后兼容。

常用的 UI 事件有：

- [x] load
- [x] unload
- [x] abort
- [x] error
- [x] select
- [x] resize
- [x] scroll

**load**

`load` 事件会在大多数通过 HTTP 进行资源请求的载体上触发。例如页面及其资源加载完毕后在 `window`对象上触发；框架内的页面加载完毕后在 `iframe` 上触发；图像、脚本、样式加载完毕后在其对应的 `img`、`script`、`link` 标签上触发；也或者嵌入式内容加载完成后在其 `<object>` 标签上触发。

除了使用 DOM0 与 DOM1 级方式来为 `window` 对象指定`load`事件的事件处理程序外，还可以通过 HTML 事件处理程序方式为 `body` 元素的 `onload` 属性指定事件处理程序：

```html
<body onload="alert(event.target === document)"></body>
```

通常在 `window` 上触发的事件，都可以在 `<body>` 元素上通过设置相应的属性来指定。而事件对象的目标元素(target)则是 `document` 对象。

我们很少会使用 `load` 事件来判断网页整体的加载情况，因为它很慢总会等待所有请求资源加载完毕后才会触发，因此 `load` 事件常用于网页局部资源的加载判断，例如对“动态样式”、“动态脚本”、“图像预加载”等技术的应用上。

先定义一个统一的加载状态判断方法：

```js
function loadState(element) {
  if (element.addEventListener) {
    element.addEventListener("load", function(event) {
      alert(event.target);
    });
  } else if (window.attachEvent) {
    element.attachEvent("onload", function(event) {
      alert(event.target);
    });
  } else {
    element.onload = function(event) {
      var e = event || window.event;
      alert(e.target);
    };
  }
}
```

接着我们开始使用 `loadState` 方法来判断外部脚本、样式的加载状态：

```js
function loadLink(element) {
  var link = document.createElement("link");
  link.rel = "stylesheet";
  link.type = "text/css";
  loadState(link);
  link.href = "example.css";
  document.head.appendChild(link);
}

function loadScript(element) {
  var script = document.createElement("script");
  link.type = "text/javascript";
  loadState(link);
  link.href = "example.js";
  document.head.appendChild(link);
```

但对于图片的预加载上，图片的加载流程与脚本、样式有很大的不同，前者只要设置了`src`属性就会开始下载，而后着只有在 `src` 以及 `href`属性被设置并添加到文档后才会开始下载，因此对于图片的预加载可以使用下面的方式：

```js
function loadImg() {
  var img = document.createElement("img");
  loadState(img);
  document.body.appendChild(img);
  img.src = "example.jpg";
}
```

另外，DOM0 级还定义了一个 `Image` 接口（构造函数），可以用来快速实例一个 `img` 元素对象。

```js
var img = new Image();
```

由于 `img` 这种只需要设置 `src` 属性而无需添加到页面中渲染就可以加载图片的特性，常用于图片缓存以及站点的访问量统计。

**unload**

与 `load` 相反 `unload` 会在页面被卸载后触发，触发页面卸载的条件有：刷新页面、跳转链接、表单提交、关闭页面窗口等。

为防止`unload`事件被滥用、大多数浏览器都会屏蔽`unload`事件处理程序中的异步请求以及浏览器原生的交互 UI 组件，但通过下面的代码，我们可以直观了解 `unload` 事件的触发。

```js
alert(localStorage.getItem("unload"));
window.onunload = function() {
  localStorage.setItem("unload", 1);
};
```

> 当我们刷新页面、跳转链接、关闭窗口后，再次进入该页面且成功的弹出了本地缓存中的值，便说明了 `unload` 事件被成功触发了。

`unload` 事件的常用场景有：

- 清除引用、避免内存泄漏。
- 关闭页面时统计与收集用户的操作信息

由于浏览器大都会阻止 `unload`事件处理程序中的异步请求，因此我们必须要通过一些特殊的技巧绕过这些限制，比如：

1. 创建一个最长几秒钟的死循环，然后来发送请求
2. 在 `unload` 中创建一个图片并设置其 `src` 来延迟卸载以保证数据的发送，因为绝大多数用户代理会延迟卸载以保证图片的载入，所以数据可以在卸载事件中发送。
3. 创建一个同步的 `XMLHttpRequest` 请求。

总的来说，上面的几种方法都不是完美的方案，总会或多或少降低下个页面的载入性能，好在 `W3C` 为 `Navigator` 对象制定了一个 `sendBeacon()` 方法，可以异步的向服务器发送信息且不影响下一个页面的加载。

```js
indow.addEventListener("unload", logData, false);

function logData() {
  navigator.sendBeacon("/log", analyticsData);
}
```

其中　`analyticsData` 就是在页面卸载的时候异步发送的数据，它可以是 ArrayBuffer、Blob、DOMString、FormData 等类型的数据。

与 `load` 事件相同，我们不仅可以使用 DOM0 级以及 DOM2 级的方式来为 `window` 对象指定 `unload` 事件处理程序，还可以通过 HTML 事件处理程序方式为 `body` 元素指定 `onunload` 事件，且事件对象的目标元素为 `document` 。

对于一个简单的页面来说，其事件的生命周期大致的顺序为：`DOMContentLoaded -> onload -> onbeforeload -> onunload`

> 参考
>
> - https://zh.javascript.info/onload-ondomcontentloaded#windowonunload
> - https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon
> - https://w3c.github.io/beacon/#introduction

**abort**
当外部请求的资源还未加载完毕时，由用户停止下载以及网络中断等原因导致内容没有加载完成时触发。
该事件被常用于 `img` 图片预加载时的判断。

**error**
当 JavaScript 代码执行错误、无法加载图片地址、框架无法加载页面时都会触发 `error` 事件。

```js
window.onerror = function(e) {
  console.log(e); //Uncaught error
};

throw "error";
```

使用 `error` 事件我们可以实现页面的错误分析、图片的预加载等。

**select**
当用户选择文本框或多行文本框中的一个或多个字符时触发。

**resize**
当浏览器的窗口大小发生变化时触发，由于该事件的事件处理程序执行频率过高，通常我们都会使用防抖以及节流来进行优化。
这个事件在 `window` 窗口上触发，因此可以通过 HTML 事件处理程序方式为 `<body>` 元素的 `onresize` 属性指定事件处理程序。

```html
<body onresize="console.log(event)"></div>
```

**scroll**
当事件对象存在滚动条且进行滚动时触发。

`scroll` 事件可以作用在所有存在滚动条的元素上，当我们为 `window` 对象指定 `scroll` 事件处理程序时，实际上触发滚动的元素还是 `<body>` 元素或者是 `html` 元素。

```js
window.onscroll = function(e) {
  console.log(
    document.scrollingElement.scrollTop ||
      document.documentElement.scrollTop ||
      document.body.scrollTop
  );
};
```

> 如果当前的模式是混杂模式则使用 `document.body.client`，如果支持 scrollingElement，则优先使用该新的特性，否则使用标准模式下的 `document.documentElement`

由于 `scroll` 事件也会被频繁的触发，所以我们在实际使用时最好要使用防抖、节流函数来进行优化。

### 鼠标事件

`click` 事件的流程是鼠标的主按钮被按下然后又松开的过程，对于一些特别的 HTML 标签，也可以在获取焦点时，通过键盘的 Enter 键或空格键触发 `click` 事件

mouseenter 相比于 mouseover 事件，不会触发冒泡，且鼠标在移动到后代元素上后再移动回来也不会触发。
mouseleave 相比于 mouseout 事件，不会发生冒泡，且鼠标在从元素上移动到后代元素上也不会触发。
我们必须要注意，鼠标移动到某个元素以及从某个元素上移出，是有两种情况的，一种就是从元素的外部移入，也或者从当前元素中移出到外部，另一种则是当前元素存在后代元素，那么当我们在元素内部移动时，如果移动到后代元素，也或者从后代元素移入到父元素的当前元素，也会触发移入移出的事件。

```htm
<div><p></p></div>
```

```js
var div = document.querySelector("div");
div.addEventListener("mouseenter", function() {
  console.log("div");
});
```

此时，将鼠标从外部移入到 `div` 中，会触发 `mouseenter` 事件，但是将鼠标在 `div` 内部移入到 `p` 元素上，再移回便不会触发 `mouseenter` 事件。

修改键，个人感觉称之为“辅助键”更为适合。当鼠标事件发生时，可以通过事件对象的相关属性来获知用户是否有同时按下键盘上特定的按键。

mousewheel,DOMMouseScroll

```js
function getDirection(wheelDelta) {
  return wheelDelta >= 0 ? "up" : "down";
}
document.documentElement.addEventListener("mousewheel", function(e) {
  console.log(getDirection(e.wheelDelta));
});
document.documentElement.addEventListener("DOMMouseScroll", function(e) {
  console.log(getDirection(-e.detail));
});
```

复合事件
由于输入法编辑器(IME)会截取键盘事件，获取用户输入的多个字符，然后输出最终的结果字符，因此我们便需要定义一个可以检测和处理这种输入而设计的事件 - “复合事件(compostion)”。

### HTML5 事件

contextmenu 属于鼠标事件，所以其事件对象包含鼠标相关的信息，例如指针的坐标。

```js
document.addEventListener("contextmenu", function(e) {
  var contextmenu = document.getElementById("contextmenu");
  if (contextmenu) {
    contextmenu.parentNode.removeChild(contextmenu);
  }

  var oDiv = document.createElement("div");
  oDiv.id = "contextmenu";
  oDiv.innerText = "contextmenu";
  oDiv.style.cssText =
    "position:absolute;padding:10;background:#ccc;border:1px solid #aaa";
  oDiv.style.left = e.clientX + "px";
  oDiv.style.top = e.clientY + "px";
  document.body.appendChild(oDiv);
  e.preventDefault();
});

document.addEventListener("click", function() {
  var contextmenu = document.getElementById("contextmenu");
  if (contextmenu) {
    contextmenu.parentNode.removeChild(contextmenu);
  }
});
```

其触发流程为 - mousedown -> mouseup -> contextmenu。

#### beforeunload

关于页面卸载前的自定义提示，目前只有 IE11-版本支持，可以通过在事件处理程序中 `return` 要返回的提示信息。

```js
window.addEventListener(
  "beforeunload",
  function(e) {
    return "are you sure？";
  },
  false
);
```

最新版本的 firefox、chrome、Microsft Edge 都已经不支持自定义提示，但是如果要打开系统提示，则必须要使用以下方式来跨浏览器支持：

```js
window.addEventListener(
  "beforeunload",
  function(e) {
    var message = "are you sure？";
    e.preventDefault(); //Edge required
    e.returnValue = message;
    return message;
  },
  false
);
```

参考：
https://zh.javascript.info/onload-ondomcontentloaded
